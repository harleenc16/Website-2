{"ast":null,"code":"var _jsxFileName = \"/Users/harleenchaudhary/Documents/Website-Final/src/components/projects/String.js\";\nimport React from 'react';\nimport './Style.css';\nimport Footer from '../Footer';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default function String() {\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"style-container\",\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"style-img\",\n        children: /*#__PURE__*/_jsxDEV(\"img\", {\n          src: \"/images/string.png\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 10,\n          columnNumber: 18\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 9,\n        columnNumber: 14\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"style-con\",\n        children: [/*#__PURE__*/_jsxDEV(\"p\", {\n          className: \"style-heading\",\n          children: \"Summary\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 14,\n          columnNumber: 17\n        }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n          className: \"style-body\",\n          children: [\" This is one of my assignments from my data structures and algorithms class. I implemented three extremely efficient string matching algorithms written in C++. All of them require a file name to be provided as user input. The first one reads from the file and finds all the ID's in a file whose digits add to a number between 31 and 68. An ID in the file is a a string with nine characters starting with the letter U followed by seven digits. The algorithm finds all the ID's and then returns all the ID's who's digits add to a number between 31 and 68. I added a bool function that checks if it is a valid ID, and if true, then the count variable is incremented and at last, the value of the count variable is returned. The second part of the problem reads from the same file and compares it to another file(in the code) and returns a count of all the words that do not begin with the letter of your first name(in this case-it's H). I implemented KMP algorithm to complete this task, as it is one of the more efficient algorithms for a heavy data set. The third part iterates through the file and finds the longest palindrome. I did this but setting up various nested for loops inside my code. The link to this code can be found \", /*#__PURE__*/_jsxDEV(\"a\", {\n            className: \"style-link\",\n            href: \"https://github.com/harleenc16/String-Matching-algorithm\",\n            children: \"here \"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 27,\n            columnNumber: 75\n          }, this), \".\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 15,\n          columnNumber: 18\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 13,\n        columnNumber: 13\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 8,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(Footer, {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 35,\n      columnNumber: 10\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 7,\n    columnNumber: 9\n  }, this);\n}\n_c = String;\n\nvar _c;\n\n$RefreshReg$(_c, \"String\");","map":{"version":3,"sources":["/Users/harleenchaudhary/Documents/Website-Final/src/components/projects/String.js"],"names":["React","Footer","String"],"mappings":";AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,OAAO,aAAP;AACA,OAAOC,MAAP,MAAmB,WAAnB;;AAEA,eAAe,SAASC,MAAT,GAAkB;AAC7B,sBACI;AAAA,4BACA;AAAK,MAAA,SAAS,EAAC,iBAAf;AAAA,8BACK;AAAK,QAAA,SAAS,EAAC,WAAf;AAAA,+BACI;AAAK,UAAA,GAAG,EAAC;AAAT;AAAA;AAAA;AAAA;AAAA;AADJ;AAAA;AAAA;AAAA;AAAA,cADL,eAKI;AAAK,QAAA,SAAS,EAAC,WAAf;AAAA,gCACI;AAAG,UAAA,SAAS,EAAC,eAAb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gBADJ,eAEK;AAAG,UAAA,SAAS,EAAC,YAAb;AAAA,ovCAYyD;AAAG,YAAA,SAAS,EAAC,YAAb;AAA0B,YAAA,IAAI,EAAC,yDAA/B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBAZzD;AAAA;AAAA;AAAA;AAAA;AAAA,gBAFL;AAAA;AAAA;AAAA;AAAA;AAAA,cALJ;AAAA;AAAA;AAAA;AAAA;AAAA,YADA,eA4BC,QAAC,MAAD;AAAA;AAAA;AAAA;AAAA,YA5BD;AAAA;AAAA;AAAA;AAAA;AAAA,UADJ;AAgCH;KAjCuBA,M","sourcesContent":["import React from 'react'\nimport './Style.css';\nimport Footer from '../Footer';\n\nexport default function String() {\n    return (\n        <div> \n        <div className='style-container'>\n             <div className='style-img'>\n                 <img src='/images/string.png' />\n            </div>\n\n            <div className='style-con'>\n                <p className='style-heading'>Summary</p>\n                 <p className='style-body'> This is one of my assignments from my data structures and algorithms class.\n                 I implemented three extremely efficient string matching algorithms written in C++. All of them require a file name to be provided as user input. \n                 The first one reads from the file and finds all the ID's in a file whose digits add to a number \n                 between 31 and 68. An ID in the file is a\n                 a string with nine characters starting with the letter U followed by seven digits. The algorithm\n                 finds all the ID's and then returns all the ID's who's digits add to a number between 31 and 68. I added\n                 a bool function that checks if it is a valid ID, and if true, then the count variable is incremented and at last, the value of the count variable is returned. \n\n                 The second part of the problem reads from the same file and compares it to another file(in the code) and returns a count of all the \n                 words that do not begin with the letter of your first name(in this case-it's H). I implemented KMP algorithm to \n                 complete this task, as it is one of the more efficient algorithms for a heavy data set. \n                 The third part iterates through the file and finds the longest palindrome. I did this but setting up various nested for\n                 loops inside my code. The link to this code can be found <a className='style-link' href='https://github.com/harleenc16/String-Matching-algorithm'>here </a>. \n                 \n                 </p>\n                \n      \n        \n          </div>  \n         </div> \n         <Footer /> \n  </div>\n    )\n}\n"]},"metadata":{},"sourceType":"module"}